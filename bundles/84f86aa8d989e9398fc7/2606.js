"use strict";(self.webpackChunkelement_web=self.webpackChunkelement_web||[]).push([[2606],{"../matrix-js-sdk/src/rust-crypto/index.ts":(e,t,s)=>{s.r(t),s.d(t,{initRustCrypto:()=>oe});var i=s("../matrix-js-sdk/node_modules/@matrix-org/matrix-sdk-crypto-wasm/pkg/matrix_sdk_crypto_wasm.js"),n=s("../matrix-js-sdk/node_modules/@babel/runtime/helpers/esm/defineProperty.js"),r=s("../matrix-js-sdk/node_modules/another-json/another-json.js"),o=s.n(r),a=s("../matrix-js-sdk/src/models/event.ts"),c=s("../matrix-js-sdk/src/http-api/index.ts"),u=s("../matrix-js-sdk/src/@types/event.ts"),g=s("../matrix-js-sdk/src/logger.ts"),h=s("../matrix-js-sdk/src/@types/partials.ts");class d{constructor(e,t,s,r,o){this.olmMachine=e,this.keyClaimManager=t,this.outgoingRequestManager=s,this.room=r,this.encryptionSettings=o,(0,n.Z)(this,"prefixedLogger",void 0),(0,n.Z)(this,"lazyLoadedMembersResolved",!1),this.prefixedLogger=g.k.getChild(`[${r.roomId} encryption]`);const a=r.getJoinedMembers();this.olmMachine.updateTrackedUsers(a.map((e=>new i.UserId(e.userId)))).catch((e=>this.prefixedLogger.error("Error initializing tracked users",e)))}onCryptoEvent(e){JSON.stringify(this.encryptionSettings)!=JSON.stringify(e)&&this.prefixedLogger.error("Ignoring m.room.encryption event which requests a change of config")}onRoomMembership(e){("join"==e.membership||"invite"==e.membership&&this.room.shouldEncryptForInvitedMembers())&&this.olmMachine.updateTrackedUsers([new i.UserId(e.userId)]).catch((e=>{this.prefixedLogger.error("Unable to update tracked users",e)}))}async prepareForEncryption(e){const t=new g.V(this.prefixedLogger,"prepareForEncryption");await this.ensureEncryptionSession(t,e)}async ensureEncryptionSession(e,t){var s;if("m.megolm.v1.aes-sha2"!==this.encryptionSettings.algorithm)throw new Error(`Cannot encrypt in ${this.room.roomId} for unsupported algorithm '${this.encryptionSettings.algorithm}'`);e.debug("Starting encryption");const n=await this.room.getEncryptionTargetMembers();this.lazyLoadedMembersResolved?(e.debug("Processing outgoing requests in background"),this.outgoingRequestManager.doProcessOutgoingRequests()):(await this.olmMachine.updateTrackedUsers(n.map((e=>new i.UserId(e.userId)))),e.debug("Updated tracked users"),this.lazyLoadedMembersResolved=!0,e.debug("Processing outgoing requests"),await this.outgoingRequestManager.doProcessOutgoingRequests()),e.debug(`Encrypting for users (shouldEncryptForInvitedMembers: ${this.room.shouldEncryptForInvitedMembers()}):`,n.map((e=>`${e.userId} (${e.membership})`)));const r=n.map((e=>new i.UserId(e.userId)));await this.keyClaimManager.ensureSessionsForUsers(e,r);const o=new i.EncryptionSettings;o.historyVisibility=function(e){switch(e){case h.GR.Invited:return i.HistoryVisibility.Invited;case h.GR.Joined:return i.HistoryVisibility.Joined;case h.GR.Shared:return i.HistoryVisibility.Shared;case h.GR.WorldReadable:return i.HistoryVisibility.WorldReadable}}(this.room.getHistoryVisibility()),o.algorithm=i.EncryptionAlgorithm.MegolmV1AesSha2,"number"==typeof this.encryptionSettings.rotation_period_ms&&(o.rotationPeriod=BigInt(1e3*this.encryptionSettings.rotation_period_ms)),"number"==typeof this.encryptionSettings.rotation_period_msgs&&(o.rotationPeriodMessages=BigInt(this.encryptionSettings.rotation_period_msgs)),o.onlyAllowTrustedDevices=null!==(s=this.room.getBlacklistUnverifiedDevices())&&void 0!==s?s:t;const a=await this.olmMachine.shareRoomKey(new i.RoomId(this.room.roomId),r,o);if(a)for(const e of a)await this.outgoingRequestManager.outgoingRequestProcessor.makeOutgoingRequest(e)}async forceDiscardSession(){await this.olmMachine.invalidateGroupSession(new i.RoomId(this.room.roomId))&&this.prefixedLogger.info("Discarded existing group session")}async encryptEvent(e,t){var s;const n=new g.V(this.prefixedLogger,null!==(s=e.getTxnId())&&void 0!==s?s:"");await this.ensureEncryptionSession(n,t),n.debug("Encrypting actual message content");const r=await this.olmMachine.encryptRoomEvent(new i.RoomId(this.room.roomId),e.getType(),JSON.stringify(e.getContent()));e.makeEncrypted(u.tw.RoomMessageEncrypted,JSON.parse(r),this.olmMachine.identityKeys.curve25519.toBase64(),this.olmMachine.identityKeys.ed25519.toBase64()),n.debug("Encrypted event successfully")}}function l(e,t){var s=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),s.push.apply(s,i)}return s}class p{constructor(e,t){this.olmMachine=e,this.http=t}async makeOutgoingRequest(e,t){let s;if(e instanceof i.KeysUploadRequest)s=await this.rawJsonRequest(c.n$.Post,"/_matrix/client/v3/keys/upload",{},e.body);else if(e instanceof i.KeysQueryRequest)s=await this.rawJsonRequest(c.n$.Post,"/_matrix/client/v3/keys/query",{},e.body);else if(e instanceof i.KeysClaimRequest)s=await this.rawJsonRequest(c.n$.Post,"/_matrix/client/v3/keys/claim",{},e.body);else if(e instanceof i.SignatureUploadRequest)s=await this.rawJsonRequest(c.n$.Post,"/_matrix/client/v3/keys/signatures/upload",{},e.body);else if(e instanceof i.KeysBackupRequest)s=await this.rawJsonRequest(c.n$.Put,"/_matrix/client/v3/room_keys/keys",{version:e.version},e.body);else if(e instanceof i.ToDeviceRequest)s=await this.sendToDeviceRequest(e);else if(e instanceof i.RoomMessageRequest){const t=`/_matrix/client/v3/rooms/${encodeURIComponent(e.room_id)}/send/${encodeURIComponent(e.event_type)}/${encodeURIComponent(e.txn_id)}`;s=await this.rawJsonRequest(c.n$.Put,t,{},e.body)}else{if(e instanceof i.UploadSigningKeysRequest)return void await this.makeRequestWithUIA(c.n$.Post,"/_matrix/client/v3/keys/device_signing/upload",{},e.body,t);g.k.warn("Unsupported outgoing message",Object.getPrototypeOf(e)),s=""}if(e.id)try{await this.olmMachine.markRequestAsSent(e.id,e.type,s)}catch(e){if(!(e instanceof Error)||"Attempt to use a moved value"!==e.message&&"null pointer passed to rust"!==e.message)throw e;g.k.log(`Ignoring error '${e.message}': client is likely shutting down`)}}async sendToDeviceRequest(e){const t=JSON.parse(e.body),s=[];for(const[e,i]of Object.entries(t.messages))for(const[t,n]of Object.entries(i))s.push(`${e}/${t} (msgid ${n[u.Vp]})`);g.k.info(`Sending batch of to-device messages. type=${e.event_type} txnid=${e.txn_id}`,s);const i=`/_matrix/client/v3/sendToDevice/${encodeURIComponent(e.event_type)}/`+encodeURIComponent(e.txn_id);return await this.rawJsonRequest(c.n$.Put,i,{},e.body)}async makeRequestWithUIA(e,t,s,i,r){if(!r)return await this.rawJsonRequest(e,t,s,i);const o=JSON.parse(i),a=await r((async i=>{const r=function(e){for(var t=1;t<arguments.length;t++){var s=null!=arguments[t]?arguments[t]:{};t%2?l(Object(s),!0).forEach((function(t){(0,n.Z)(e,t,s[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(s)):l(Object(s)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(s,t))}))}return e}({},o);null!==i&&(r.auth=i);const a=await this.rawJsonRequest(e,t,s,JSON.stringify(r));return JSON.parse(a)}));return JSON.stringify(a)}async rawJsonRequest(e,t,s,i){return await this.http.authedRequest(e,t,s,i,{json:!1,headers:{"Content-Type":"application/json",Accept:"application/json"},prefix:""})}}class y{constructor(e,t){this.olmMachine=e,this.outgoingRequestProcessor=t,(0,n.Z)(this,"currentClaimPromise",void 0),(0,n.Z)(this,"stopped",!1),this.currentClaimPromise=Promise.resolve()}stop(){this.stopped=!0}ensureSessionsForUsers(e,t){const s=this.currentClaimPromise.catch((()=>{})).then((()=>this.ensureSessionsForUsersInner(e,t)));return this.currentClaimPromise=s,s}async ensureSessionsForUsersInner(e,t){if(this.stopped)throw new Error("Cannot ensure Olm sessions: shutting down");e.info("Checking for missing Olm sessions");const s=await this.olmMachine.getMissingSessions(t);s&&(e.info("Making /keys/claim request"),await this.outgoingRequestProcessor.makeOutgoingRequest(s)),e.info("Olm sessions prepared")}}var m=s("../matrix-js-sdk/src/utils.ts"),f=s("../matrix-js-sdk/src/crypto-api.ts"),k=s("../matrix-js-sdk/src/models/device.ts");function w(e,t){const s=new Map;for(const[t,i]of e.keys.entries())s.set(t.toString(),i.toBase64());let n=k.f.Unverified;e.isBlacklisted()?n=k.f.Blocked:e.isVerified()&&(n=k.f.Verified);const r=new Map,o=e.signatures.get(t);if(o){const e=new Map;for(const[t,s]of o.entries())s.isValid()&&s.signature&&e.set(t,s.signature.toBase64());r.set(t.toString(),e)}const a=e.algorithms,c=new Set;return a.forEach((e=>{switch(e){case i.EncryptionAlgorithm.MegolmV1AesSha2:c.add("m.megolm.v1.aes-sha2");break;case i.EncryptionAlgorithm.OlmV1Curve25519AesSha2:default:c.add("m.olm.v1.curve25519-aes-sha2")}})),new k.A({deviceId:e.deviceId.toString(),userId:t.toString(),keys:s,algorithms:Array.from(c),verified:n,signatures:r,displayName:e.displayName})}function v(e){var t;const s=new Map(Object.entries(e.keys)),i=null===(t=e.unsigned)||void 0===t?void 0:t.device_display_name,n=new Map;if(e.signatures)for(const t in e.signatures)n.set(t,new Map(Object.entries(e.signatures[t])));return new k.A({deviceId:e.device_id,userId:e.user_id,keys:s,algorithms:e.algorithms,verified:k.f.Unverified,signatures:n,displayName:i})}var S=s("../matrix-js-sdk/src/secret-storage.ts");class b{constructor(e,t,s){this.olmMachine=e,this.outgoingRequestProcessor=t,this.secretStorage=s}async bootstrapCrossSigning(e){if(e.setupNewCrossSigning)return void await this.resetCrossSigning(e.authUploadDeviceSigningKeys);const t=await this.olmMachine.crossSigningStatus(),s=await this.secretStorage.get("m.cross_signing.master"),i=await this.secretStorage.get("m.cross_signing.self_signing"),n=await this.secretStorage.get("m.cross_signing.user_signing"),r=Boolean(s&&i&&n),o=t.hasMaster&&t.hasUserSigning&&t.hasSelfSigning;if(g.k.log("bootstrapCrossSigning: starting",{setupNewCrossSigning:e.setupNewCrossSigning,olmDeviceHasMaster:t.hasMaster,olmDeviceHasUserSigning:t.hasUserSigning,olmDeviceHasSelfSigning:t.hasSelfSigning,privateKeysInSecretStorage:r}),o)await this.secretStorage.hasKey()?r?g.k.log("bootstrapCrossSigning: Olm device has private keys and they are saved in secret storage; doing nothing"):(g.k.log("bootstrapCrossSigning: Olm device has private keys: exporting to secret storage"),await this.exportCrossSigningKeysToStorage()):g.k.warn("bootstrapCrossSigning: Olm device has private keys, but secret storage is not yet set up; doing nothing for now.");else if(r){g.k.log("bootstrapCrossSigning: Cross-signing private keys not found locally, but they are available in secret storage, reading storage and caching locally"),await this.olmMachine.importCrossSigningKeys(s,i,n);const e=await this.olmMachine.getDevice(this.olmMachine.userId,this.olmMachine.deviceId);try{const t=await e.verify();await this.outgoingRequestProcessor.makeOutgoingRequest(t)}finally{e.free()}}else g.k.log("bootstrapCrossSigning: Cross-signing private keys not found locally or in secret storage, creating new keys"),await this.resetCrossSigning(e.authUploadDeviceSigningKeys);g.k.log("bootstrapCrossSigning: complete")}async resetCrossSigning(e){const t=await this.olmMachine.bootstrapCrossSigning(!0);await this.secretStorage.hasKey()?(g.k.log("resetCrossSigning: exporting to secret storage"),await this.exportCrossSigningKeysToStorage()):g.k.warn("resetCrossSigning: Secret storage is not yet set up; not exporting keys to secret storage yet."),g.k.log("resetCrossSigning: publishing keys to server");for(const s of[t.uploadKeysRequest,t.uploadSigningKeysRequest,t.uploadSignaturesRequest])s&&await this.outgoingRequestProcessor.makeOutgoingRequest(s,e)}async exportCrossSigningKeysToStorage(){const e=await this.olmMachine.exportCrossSigningKeys();null!=e&&e.masterKey?await this.secretStorage.store("m.cross_signing.master",e.masterKey):g.k.error("Cannot export MSK to secret storage, private key unknown"),null!=e&&e.self_signing_key?await this.secretStorage.store("m.cross_signing.self_signing",e.self_signing_key):g.k.error("Cannot export SSK to secret storage, private key unknown"),null!=e&&e.userSigningKey?await this.secretStorage.store("m.cross_signing.user_signing",e.userSigningKey):g.k.error("Cannot export USK to secret storage, private key unknown")}}async function R(e){return K(e,["m.cross_signing.master","m.cross_signing.user_signing","m.cross_signing.self_signing"])}async function K(e,t){const s=await e.getDefaultKeyId();if(!s)return!1;for(const i of t){if(!(s in(await e.isStored(i)||{})))return!1}return!0}var C=s("../matrix-js-sdk/src/crypto/key_passphrase.ts"),I=s("../matrix-js-sdk/src/crypto/recoverykey.ts"),_=s("../matrix-js-sdk/src/crypto/crypto.ts"),M=s("../matrix-js-sdk/src/crypto-api/verification.ts"),E=s("../matrix-js-sdk/src/models/typed-event-emitter.ts"),q=s("../matrix-js-sdk/src/ReEmitter.ts"),B=s("./node_modules/buffer/index.js").lW;class D extends E.L{constructor(e,t,s,r){super(),this.olmMachine=e,this.inner=t,this.outgoingRequestProcessor=s,this.supportedVerificationMethods=r,(0,n.Z)(this,"reEmitter",void 0),(0,n.Z)(this,"_accepting",!1),(0,n.Z)(this,"_cancelling",!1),(0,n.Z)(this,"_verifier",void 0),this.reEmitter=new q.S(this);t.registerChangesCallback((async()=>{const e=this.inner.getVerification();e instanceof i.Sas?(void 0===this._verifier||this._verifier instanceof V)&&this.setVerifier(new P(e,this,s)):e instanceof i.Qr&&void 0===this._verifier&&this.setVerifier(new V(e,s)),this.emit(M.FG.Change)}))}setVerifier(e){this._verifier&&this.reEmitter.stopReEmitting(this._verifier,[M.FG.Change]),this._verifier=e,this.reEmitter.reEmit(this._verifier,[M.FG.Change])}get transactionId(){return this.inner.flowId}get roomId(){var e;return null===(e=this.inner.roomId)||void 0===e?void 0:e.toString()}get initiatedByMe(){return this.inner.weStarted()}get otherUserId(){return this.inner.otherUserId.toString()}get otherDeviceId(){var e;return null===(e=this.inner.otherDeviceId)||void 0===e?void 0:e.toString()}async getOtherDevice(){const e=this.inner.otherDeviceId;if(e)return await this.olmMachine.getDevice(this.inner.otherUserId,e,5)}get isSelfVerification(){return this.inner.isSelfVerification()}get phase(){const e=this.inner.phase();switch(e){case i.VerificationRequestPhase.Created:case i.VerificationRequestPhase.Requested:return M.eV.Requested;case i.VerificationRequestPhase.Ready:return this._accepting?M.eV.Requested:M.eV.Ready;case i.VerificationRequestPhase.Transitioned:if(!this._verifier)throw new Error("VerificationRequest: inner phase == Transitioned but no verifier!");return this._verifier.verificationPhase;case i.VerificationRequestPhase.Done:return M.eV.Done;case i.VerificationRequestPhase.Cancelled:return M.eV.Cancelled}throw new Error(`Unknown verification phase ${e}`)}get pending(){if(this.inner.isPassive())return!1;const e=this.phase;return e!==M.eV.Done&&e!==M.eV.Cancelled}get accepting(){return this._accepting}get declining(){return this._cancelling}get timeout(){return this.inner.timeRemainingMillis()}get methods(){throw new Error("not implemented")}get chosenMethod(){if(this.phase!==M.eV.Started)return null;const e=this.inner.getVerification();return e instanceof i.Sas?"m.sas.v1":e instanceof i.Qr?"m.reciprocate.v1":null}otherPartySupportsMethod(e){const t=this.inner.theirSupportedMethods;if(void 0===t)return!1;const s=U[e];return t.some((e=>e===s))}async accept(){if(this.inner.phase()!==i.VerificationRequestPhase.Requested||this._accepting)throw new Error(`Cannot accept a verification request in phase ${this.phase}`);this._accepting=!0;try{const e=this.inner.acceptWithMethods(this.supportedVerificationMethods.map(x));e&&await this.outgoingRequestProcessor.makeOutgoingRequest(e)}finally{this._accepting=!1}this.emit(M.FG.Change)}async cancel(e){if(!this._cancelling){this._cancelling=!0;try{const e=this.inner.cancel();e&&await this.outgoingRequestProcessor.makeOutgoingRequest(e)}finally{this._cancelling=!1}}}beginKeyVerification(e,t){throw new Error("not implemented")}async startVerification(e){if("m.sas.v1"!==e)throw new Error(`Unsupported verification method ${e}`);if(!await this.getOtherDevice())throw new Error("startVerification(): other device is unknown");const t=await this.inner.startSas();if(t){const[,e]=t;await this.outgoingRequestProcessor.makeOutgoingRequest(e)}if(!this._verifier)throw new Error("Still no verifier after startSas() call");return this._verifier}async scanQRCode(e){const t=i.QrCodeScan.fromBytes(new Uint8ClampedArray(e)),s=await this.inner.scanQrCode(t);if(!this._verifier)throw new Error("Still no verifier after scanQrCode() call");const n=s.reciprocate();return n&&await this.outgoingRequestProcessor.makeOutgoingRequest(n),this._verifier}get verifier(){return this.phase===M.eV.Started?this._verifier:void 0}getQRCodeBytes(){throw new Error("getQRCodeBytes() unsupported in Rust Crypto; use generateQRCode() instead.")}async generateQRCode(){if(!await this.getOtherDevice())throw new Error("generateQRCode(): other device is unknown");const e=await this.inner.generateQrCode();if(e)return B.from(e.toBytes())}get cancellationCode(){throw new Error("not implemented")}get cancellingUserId(){throw new Error("not implemented")}}class O extends E.L{constructor(e,t){super(),this.inner=e,this.outgoingRequestProcessor=t,(0,n.Z)(this,"completionPromise",void 0),this.completionPromise=new Promise(((t,s)=>{e.registerChangesCallback((async()=>{if(this.onChange(),this.inner.isDone())t(void 0);else if(this.inner.isCancelled()){const e=this.inner.cancelInfo();s(new Error(`Verification cancelled by ${e.cancelledbyUs()?"us":"them"} with code ${e.cancelCode()}: ${e.reason()}`))}this.emit(M.FG.Change)}))})),this.completionPromise.catch((()=>null))}onChange(){}get hasBeenCancelled(){return this.inner.isCancelled()}get userId(){return this.inner.otherUserId.toString()}cancel(e){const t=this.inner.cancel();t&&this.outgoingRequestProcessor.makeOutgoingRequest(t)}getShowSasCallbacks(){return null}getReciprocateQrCodeCallbacks(){return null}}class V extends O{constructor(e,t){super(e,t),(0,n.Z)(this,"callbacks",null)}onChange(){null===this.callbacks&&this.inner.hasBeenScanned()&&(this.callbacks={confirm:()=>this.confirmScanning(),cancel:()=>this.cancel()})}async verify(){null!==this.callbacks&&this.emit(M.yn.ShowReciprocateQr,this.callbacks),await this.completionPromise}get verificationPhase(){switch(this.inner.state()){case i.QrState.Created:return M.eV.Ready;case i.QrState.Scanned:case i.QrState.Confirmed:case i.QrState.Reciprocated:return M.eV.Started;case i.QrState.Done:return M.eV.Done;case i.QrState.Cancelled:return M.eV.Cancelled;default:throw new Error(`Unknown qr code state ${this.inner.state()}`)}}getReciprocateQrCodeCallbacks(){return this.callbacks}async confirmScanning(){const e=this.inner.confirmScanning();e&&await this.outgoingRequestProcessor.makeOutgoingRequest(e)}}class P extends O{constructor(e,t,s){super(e,s),(0,n.Z)(this,"callbacks",null)}async verify(){const e=this.inner.accept();e&&await this.outgoingRequestProcessor.makeOutgoingRequest(e),await this.completionPromise}onChange(){if(null===this.callbacks){const e=this.inner.emoji(),t=this.inner.decimals();if(void 0===e&&void 0===t)return;this.callbacks={sas:{decimal:t,emoji:null==e?void 0:e.map((e=>[e.symbol,e.description]))},confirm:async()=>{const e=await this.inner.confirm();for(const t of e)await this.outgoingRequestProcessor.makeOutgoingRequest(t)},mismatch:()=>{throw new Error("impl")},cancel:()=>{throw new Error("impl")}},this.emit(M.yn.ShowSas,this.callbacks)}}get verificationPhase(){return M.eV.Started}getShowSasCallbacks(){return this.callbacks}}const U={"m.sas.v1":i.VerificationMethod.SasV1,"m.qr_code.scan.v1":i.VerificationMethod.QrCodeScanV1,"m.qr_code.show.v1":i.VerificationMethod.QrCodeShowV1,"m.reciprocate.v1":i.VerificationMethod.ReciprocateV1};function x(e){const t=U[e];if(void 0===t)throw new Error(`Unknown verification method ${e}`);return t}var T=s("../matrix-js-sdk/src/crypto/index.ts");class N extends E.L{constructor(e,t,s){super(),this.olmMachine=e,this.http=t,this.outgoingRequestProcessor=s,(0,n.Z)(this,"checkedForBackup",!1),(0,n.Z)(this,"activeBackupVersion",null),(0,n.Z)(this,"stopped",!1),(0,n.Z)(this,"backupKeysLoopRunning",!1),(0,n.Z)(this,"keyBackupCheckInProgress",null)}stop(){this.stopped=!0}async getActiveBackupVersion(){return await this.olmMachine.isBackupEnabled()?this.activeBackupVersion:null}async isKeyBackupTrusted(e){const t=await this.olmMachine.verifyBackup(e),s=await this.olmMachine.getBackupKeys(),i=null==s?void 0:s.decryptionKey;return{matchesDecryptionKey:!!i&&$(e,i),trusted:t.trusted()}}checkKeyBackupAndEnable(e){return!e&&this.checkedForBackup?Promise.resolve(null):(this.keyBackupCheckInProgress||(this.keyBackupCheckInProgress=this.doCheckKeyBackup().finally((()=>{this.keyBackupCheckInProgress=null}))),this.keyBackupCheckInProgress)}async handleBackupSecretReceived(e){var t;const s=await this.checkKeyBackupAndEnable(!0);if(null==s||null===(t=s.backupInfo)||void 0===t||!t.version||!s.trustInfo.trusted)return g.k.warn("Received backup decryption key, but there is no trusted server-side key backup"),!1;try{const t=i.BackupDecryptionKey.fromBase64(e);return $(s.backupInfo,t)?(g.k.info("handleBackupSecretReceived: A valid backup decryption key has been received and stored in cache."),await this.saveBackupDecryptionKey(t,s.backupInfo.version),!0):(g.k.debug("onReceiveSecret: backup decryption key does not match current backup version"),!1)}catch(e){g.k.warn("handleBackupSecretReceived: Invalid backup decryption key",e)}return!1}async saveBackupDecryptionKey(e,t){await this.olmMachine.saveBackupDecryptionKey(e,t),this.emit(T.qG.KeyBackupDecryptionKeyCached,t)}async importRoomKeys(e,t){const s=JSON.stringify(e);await this.olmMachine.importExportedRoomKeys(s,((e,s)=>{var i;const n={total:Number(s),successes:Number(e),stage:"load_keys",failures:0};null==t||null===(i=t.progressCallback)||void 0===i||i.call(t,n)}))}async importBackedUpRoomKeys(e,t){const s=new Map;for(const t of e){const e=new i.RoomId(t.room_id);s.has(e)||s.set(e,new Map),s.get(e).set(t.session_id,t)}await this.olmMachine.importBackedUpRoomKeys(s,((e,s)=>{var i;const n={total:Number(s),successes:Number(e),stage:"load_keys",failures:0};null==t||null===(i=t.progressCallback)||void 0===i||i.call(t,n)}))}async doCheckKeyBackup(){g.k.log("Checking key backup status...");let e=null;try{e=await this.requestKeyBackupVersion()}catch(e){return g.k.warn("Error checking for active key backup",e),null}this.checkedForBackup=!0,e&&!e.version&&g.k.warn("active backup lacks a useful 'version'; ignoring it");const t=await this.getActiveBackupVersion();if(!e)return null!==t?(g.k.log("No key backup present on server: disabling key backup"),await this.disableKeyBackup()):g.k.log("No key backup present on server: not enabling key backup"),null;const s=await this.isKeyBackupTrusted(e);return s.trusted?null===t?(g.k.log(`Found usable key backup v${e.version}: enabling key backups`),await this.enableKeyBackup(e)):t!==e.version?(g.k.log(`On backup version ${t} but found version ${e.version}: switching.`),await this.disableKeyBackup(),await this.enableKeyBackup(e)):g.k.log(`Backup version ${e.version} still current`):null!==t?(g.k.log("Key backup present on server but not trusted: disabling key backup"),await this.disableKeyBackup()):g.k.log("Key backup present on server but not trusted: not enabling key backup"),{backupInfo:e,trustInfo:s}}async enableKeyBackup(e){await this.olmMachine.enableBackupV1(e.auth_data.public_key,e.version),this.activeBackupVersion=e.version,this.emit(T.qG.KeyBackupStatus,!0),this.backupKeysLoop()}async maybeUploadKey(){null!=this.activeBackupVersion&&this.backupKeysLoop()}async disableKeyBackup(){await this.olmMachine.disableBackup(),this.activeBackupVersion=null,this.emit(T.qG.KeyBackupStatus,!1)}async backupKeysLoop(e=1e4){if(this.backupKeysLoopRunning)return void g.k.log("Backup loop already running");this.backupKeysLoopRunning=!0,g.k.log(`Backup: Starting keys upload loop for backup version:${this.activeBackupVersion}.`);const t=Math.random()*e;await(0,m._v)(t);try{let e=0;for(;!this.stopped;){let t=null;try{t=await this.olmMachine.backupRoomKeys()}catch(e){g.k.error("Backup: Failed to get keys to backup from rust crypto-sdk",e)}if(!t||this.stopped||!this.activeBackupVersion)return void g.k.log(`Backup: Ending loop for version ${this.activeBackupVersion}.`);try{if(await this.outgoingRequestProcessor.makeOutgoingRequest(t),e=0,this.stopped)break;try{const e=await this.olmMachine.roomKeyCounts(),t=e.total-e.backedUp;this.emit(T.qG.KeyBackupSessionsRemaining,t)}catch(e){g.k.error("Backup: Failed to get key counts from rust crypto-sdk",e)}}catch(t){if(e++,g.k.error("Backup: Error processing backup request for rust crypto-sdk",t),t instanceof c.OI){const e=t.data.errcode;if("M_NOT_FOUND"==e||"M_WRONG_ROOM_KEYS_VERSION"==e){g.k.log(`Backup: Failed to upload keys to current vesion: ${e}.`);try{await this.disableKeyBackup()}catch(e){g.k.error("Backup: An error occurred while disabling key backup:",e)}return this.emit(T.qG.KeyBackupFailed,t.data.errcode),this.backupKeysLoopRunning=!1,void this.checkKeyBackupAndEnable(!0)}if("M_LIMIT_EXCEEDED"==e){const e=t.data.retry_after_ms;if(e>0){(0,m._v)(e);continue}}}await(0,m._v)(1e3*Math.pow(2,Math.min(e-1,4)))}}}finally{this.backupKeysLoopRunning=!1}}async requestKeyBackupVersion(){try{return await this.http.authedRequest(c.n$.Get,"/room_keys/version",void 0,void 0,{prefix:c.wI.V3})}catch(e){if("M_NOT_FOUND"===e.errcode)return null;throw e}}async setupKeyBackup(e){await this.deleteAllKeyBackupVersions();const t=i.BackupDecryptionKey.createRandomKey(),s=t.megolmV1PublicKey,n={public_key:s.publicKeyBase64};await e(n);const r=await this.http.authedRequest(c.n$.Post,"/room_keys/version",void 0,{algorithm:s.algorithm,auth_data:n},{prefix:c.wI.V3});return await this.saveBackupDecryptionKey(t,r.version),{version:r.version,algorithm:s.algorithm,authData:n,decryptionKey:t}}async deleteAllKeyBackupVersions(){var e,t;let s=null!==(e=null===(t=await this.requestKeyBackupVersion())||void 0===t?void 0:t.version)&&void 0!==e?e:null;for(;null!=s;){var i,n;await this.deleteKeyBackupVersion(s),s=null!==(i=null===(n=await this.requestKeyBackupVersion())||void 0===n?void 0:n.version)&&void 0!==i?i:null}}async deleteKeyBackupVersion(e){g.k.debug(`deleteKeyBackupVersion v:${e}`);const t=(0,m.Hh)("/room_keys/version/$version",{$version:e});await this.http.authedRequest(c.n$.Delete,t,void 0,void 0,{prefix:c.wI.V3})}createBackupDecryptor(e){return new L(e)}}function $(e,t){var s;return"m.megolm_backup.v1.curve25519-aes-sha2"!==e.algorithm?(g.k.warn("backupMatchesPrivateKey: Unsupported backup algorithm",e.algorithm),!1):(null===(s=e.auth_data)||void 0===s?void 0:s.public_key)===t.megolmV1PublicKey.publicKeyBase64}class L{constructor(e){(0,n.Z)(this,"decryptionKey",void 0),(0,n.Z)(this,"sourceTrusted",void 0),this.decryptionKey=e,this.sourceTrusted=!1}async decryptSessions(e){const t=[];for(const[s,i]of Object.entries(e))try{const e=JSON.parse(this.decryptionKey.decryptV1(i.session_data.ephemeral,i.session_data.mac,i.session_data.ciphertext));e.session_id=s,t.push(e),await(0,m.j8)()}catch(e){g.k.log("Failed to decrypt megolm session from backup",e,i)}return t}free(){this.decryptionKey.free()}}var j=s("../matrix-js-sdk/src/randomstring.ts"),A=s("../matrix-js-sdk/src/errors.ts"),F=s("../matrix-js-sdk/src/base64.ts"),Z=s("../matrix-js-sdk/src/crypto/algorithms/index.ts");class G{constructor(e,t,s){this.logger=e,this.olmMachine=t,this.outgoingRequestProcessor=s,(0,n.Z)(this,"stopped",!1),(0,n.Z)(this,"outgoingRequestLoopRunning",!1),(0,n.Z)(this,"nextLoopDeferred",void 0)}stop(){this.stopped=!0}doProcessOutgoingRequests(){this.nextLoopDeferred||(this.nextLoopDeferred=(0,m.PQ)());const e=this.nextLoopDeferred.promise;return this.outgoingRequestLoopRunning||this.outgoingRequestLoop().catch((e=>{this.logger.error("Uncaught error in outgoing request loop",e)})),e}async outgoingRequestLoop(){if(this.outgoingRequestLoopRunning)throw new Error("Cannot run two outgoing request loops");this.outgoingRequestLoopRunning=!0;try{for(;!this.stopped&&this.nextLoopDeferred;){const e=this.nextLoopDeferred;this.nextLoopDeferred=void 0,await this.processOutgoingRequests().then(e.resolve,e.reject)}}finally{this.outgoingRequestLoopRunning=!1}this.nextLoopDeferred&&this.nextLoopDeferred.reject(new Error("OutgoingRequestsManager was stopped"))}async processOutgoingRequests(){if(this.stopped)return;const e=await this.olmMachine.outgoingRequests();for(const t of e){if(this.stopped)return;try{await this.outgoingRequestProcessor.makeOutgoingRequest(t)}catch(e){this.logger.error(`Failed to process outgoing request ${t.type}: ${e}`)}}}}var J=s("../matrix-js-sdk/src/matrix.ts");const Q=5e3;var W=function(e){return e.MISSING_DECRYPTION_KEY="MISSING_DECRYPTION_KEY",e.NETWORK_ERROR="NETWORK_ERROR",e.STOPPED="STOPPED",e}(W||{});class H extends Error{constructor(e){super(`Failed to get key from backup: ${e}`),this.code=e,this.name="KeyDownloadError"}}class Y extends Error{constructor(e){super("Failed to get key from backup: rate limited"),this.retryMillis=e,this.name="KeyDownloadRateLimitError"}}class z{constructor(e,t,s,i){this.olmMachine=t,this.http=s,this.backupManager=i,(0,n.Z)(this,"stopped",!1),(0,n.Z)(this,"configuration",null),(0,n.Z)(this,"sessionLastCheckAttemptedTime",new Map),(0,n.Z)(this,"logger",void 0),(0,n.Z)(this,"downloadLoopRunning",!1),(0,n.Z)(this,"queuedRequests",[]),(0,n.Z)(this,"hasConfigurationProblem",!1),(0,n.Z)(this,"currentBackupVersionCheck",null),(0,n.Z)(this,"onBackupStatusChanged",(()=>{this.hasConfigurationProblem=!1,this.configuration=null,this.getOrCreateBackupConfiguration().then((e=>{e&&this.downloadKeysLoop()}))})),this.logger=e.getChild("[PerSessionKeyBackupDownloader]"),i.on(J.CryptoEvent.KeyBackupStatus,this.onBackupStatusChanged),i.on(J.CryptoEvent.KeyBackupFailed,this.onBackupStatusChanged),i.on(J.CryptoEvent.KeyBackupDecryptionKeyCached,this.onBackupStatusChanged)}onDecryptionKeyMissingError(e,t){this.isAlreadyInQueue(e,t)?this.logger.trace(`Not checking key backup for session ${t} as it is already queued`):this.wasRequestedRecently(t)?this.logger.trace(`Not checking key backup for session ${t} as it was already requested recently`):(this.queuedRequests.push({roomId:e,megolmSessionId:t}),this.downloadKeysLoop())}stop(){this.stopped=!0,this.backupManager.off(J.CryptoEvent.KeyBackupStatus,this.onBackupStatusChanged),this.backupManager.off(J.CryptoEvent.KeyBackupFailed,this.onBackupStatusChanged),this.backupManager.off(J.CryptoEvent.KeyBackupDecryptionKeyCached,this.onBackupStatusChanged)}isAlreadyInQueue(e,t){return this.queuedRequests.some((s=>s.roomId==e&&s.megolmSessionId==t))}markAsNotFoundInBackup(e){const t=Date.now();this.sessionLastCheckAttemptedTime.set(e,t),this.sessionLastCheckAttemptedTime.size>100&&(this.sessionLastCheckAttemptedTime=new Map(Array.from(this.sessionLastCheckAttemptedTime).filter(((e,s)=>Math.max(t-s,0)<Q))))}wasRequestedRecently(e){const t=this.sessionLastCheckAttemptedTime.get(e);return!!t&&Math.max(Date.now()-t,0)<Q}async getBackupDecryptionKey(){try{return await this.olmMachine.getBackupKeys()}catch(e){return null}}async requestRoomKeyFromBackup(e,t,s){const i=(0,m.Hh)("/room_keys/keys/$roomId/$sessionId",{$roomId:t,$sessionId:s});return await this.http.authedRequest(c.n$.Get,i,{version:e},void 0,{prefix:c.wI.V3})}async downloadKeysLoop(){if(!this.downloadLoopRunning&&!this.hasConfigurationProblem){this.downloadLoopRunning=!0;try{for(;this.queuedRequests.length>0;){const e=this.queuedRequests[0];try{const t=await this.getOrCreateBackupConfiguration();if(!t)return void(this.downloadLoopRunning=!1);const s=await this.queryKeyBackup(e.roomId,e.megolmSessionId,t);if(this.stopped)return;try{await this.decryptAndImport(e,s,t)}catch(t){this.logger.error(`Error while decrypting and importing key backup for session ${e.megolmSessionId}`,t)}this.queuedRequests.shift()}catch(t){if(t instanceof H)switch(t.code){case W.MISSING_DECRYPTION_KEY:this.markAsNotFoundInBackup(e.megolmSessionId),this.queuedRequests.shift();break;case W.NETWORK_ERROR:await(0,m._v)(Q);break;case W.STOPPED:return void(this.downloadLoopRunning=!1)}else t instanceof Y&&await(0,m._v)(t.retryMillis)}}}finally{this.downloadLoopRunning=!1}}}async queryKeyBackup(e,t,s){if(this.logger.debug(`Checking key backup for session ${t}`),this.stopped)throw new H(W.STOPPED);try{const i=await this.requestRoomKeyFromBackup(s.backupVersion,e,t);return this.logger.debug(`Got key from backup for sessionId:${t}`),i}catch(e){if(this.stopped)throw new H(W.STOPPED);if(this.logger.info(`No luck requesting key backup for session ${t}: ${e}`),e instanceof c.OI){const t=e.data.errcode;if("M_NOT_FOUND"==t)throw new H(W.MISSING_DECRYPTION_KEY);if("M_LIMIT_EXCEEDED"==t){const t=e.data.retry_after_ms;throw t>0?(this.logger.info(`Rate limited by server, waiting ${t}ms`),new Y(t)):new Y(Q)}}throw new H(W.NETWORK_ERROR)}}async decryptAndImport(e,t,s){const i={[e.megolmSessionId]:t},n=await s.decryptor.decryptSessions(i);for(const t of n)t.room_id=e.roomId;await this.backupManager.importBackedUpRoomKeys(n)}async getOrCreateBackupConfiguration(){if(this.configuration)return this.configuration;if(this.hasConfigurationProblem)return null;if(null!=this.currentBackupVersionCheck)return this.logger.debug("Already checking server version, use current promise"),await this.currentBackupVersionCheck;this.currentBackupVersionCheck=this.internalCheckFromServer();try{return await this.currentBackupVersionCheck}finally{this.currentBackupVersionCheck=null}}async internalCheckFromServer(){var e,t,s;let i=null;try{i=await this.backupManager.requestKeyBackupVersion()}catch(e){return this.logger.debug(`Backup: error while checking server version: ${e}`),this.hasConfigurationProblem=!0,null}var n;if(this.logger.debug(`Got current backup version from server: ${null===(e=i)||void 0===e?void 0:e.version}`),"m.megolm_backup.v1.curve25519-aes-sha2"!=(null===(t=i)||void 0===t?void 0:t.algorithm))return this.logger.info(`Unsupported algorithm ${null===(n=i)||void 0===n?void 0:n.algorithm}`),this.hasConfigurationProblem=!0,null;if(null===(s=i)||void 0===s||!s.version)return this.logger.info("No current key backup"),this.hasConfigurationProblem=!0,null;const r=await this.backupManager.getActiveBackupVersion();if(null==r||i.version!=r)return this.logger.info(`The current backup version on the server (${i.version}) is not trusted. Version we are currently backing up to: ${r}`),this.hasConfigurationProblem=!0,null;const o=i.auth_data,a=await this.getBackupDecryptionKey();if(null==a||!a.decryptionKey)return this.logger.debug("Not checking key backup for session (no decryption key)"),this.hasConfigurationProblem=!0,null;if(r!=a.backupVersion)return this.logger.debug(`Version for which we have a decryption key (${a.backupVersion}) doesn't match the version we are backing up to (${r})`),this.hasConfigurationProblem=!0,null;if(o.public_key!=a.decryptionKey.megolmV1PublicKey.publicKeyBase64)return this.logger.debug("getBackupDecryptor key mismatch error"),this.hasConfigurationProblem=!0,null;const c=this.backupManager.createBackupDecryptor(a.decryptionKey);return this.hasConfigurationProblem=!1,this.configuration={decryptor:c,backupVersion:r},this.configuration}}var X=s("./node_modules/buffer/index.js").lW;function ee(e,t){var s=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),s.push.apply(s,i)}return s}function te(e){for(var t=1;t<arguments.length;t++){var s=null!=arguments[t]?arguments[t]:{};t%2?ee(Object(s),!0).forEach((function(t){(0,n.Z)(e,t,s[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(s)):ee(Object(s)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(s,t))}))}return e}const se=["m.sas.v1","m.qr_code.scan.v1","m.qr_code.show.v1","m.reciprocate.v1"];class ie extends E.L{constructor(e,t,s,i,r,o,a){super(),this.logger=e,this.olmMachine=t,this.http=s,this.userId=i,this.secretStorage=o,this.cryptoCallbacks=a,(0,n.Z)(this,"_trustCrossSignedDevices",!0),(0,n.Z)(this,"stopped",!1),(0,n.Z)(this,"roomEncryptors",{}),(0,n.Z)(this,"eventDecryptor",void 0),(0,n.Z)(this,"keyClaimManager",void 0),(0,n.Z)(this,"outgoingRequestProcessor",void 0),(0,n.Z)(this,"crossSigningIdentity",void 0),(0,n.Z)(this,"backupManager",void 0),(0,n.Z)(this,"outgoingRequestsManager",void 0),(0,n.Z)(this,"perSessionBackupDownloader",void 0),(0,n.Z)(this,"reemitter",new q.S(this)),(0,n.Z)(this,"globalBlacklistUnverifiedDevices",!1),(0,n.Z)(this,"_supportedVerificationMethods",se),this.outgoingRequestProcessor=new p(t,s),this.outgoingRequestsManager=new G(this.logger,t,this.outgoingRequestProcessor),this.keyClaimManager=new y(t,this.outgoingRequestProcessor),this.backupManager=new N(t,s,this.outgoingRequestProcessor),this.perSessionBackupDownloader=new z(this.logger,this.olmMachine,this.http,this.backupManager),this.eventDecryptor=new ne(this.logger,t,this.perSessionBackupDownloader),this.reemitter.reEmit(this.backupManager,[T.qG.KeyBackupStatus,T.qG.KeyBackupSessionsRemaining,T.qG.KeyBackupFailed,T.qG.KeyBackupDecryptionKeyCached]),this.crossSigningIdentity=new b(t,this.outgoingRequestProcessor,o),this.checkKeyBackupAndEnable()}getOlmMachineOrThrow(){if(this.stopped)throw new A.Sb;return this.olmMachine}set globalErrorOnUnknownDevices(e){}get globalErrorOnUnknownDevices(){return!1}stop(){this.stopped||(this.stopped=!0,this.keyClaimManager.stop(),this.backupManager.stop(),this.outgoingRequestsManager.stop(),this.perSessionBackupDownloader.stop(),this.olmMachine.close())}async encryptEvent(e,t){const s=e.getRoomId(),i=this.roomEncryptors[s];if(!i)throw new Error(`Cannot encrypt event in unconfigured room ${s}`);await i.encryptEvent(e,this.globalBlacklistUnverifiedDevices)}async decryptEvent(e){if(!e.getRoomId())throw new Error("to-device event was not decrypted in preprocessToDeviceMessages");return await this.eventDecryptor.attemptEventDecryption(e)}getEventEncryptionInfo(e){var t;const s={};return s.senderKey=null!==(t=e.getSenderKey())&&void 0!==t?t:void 0,s.algorithm=e.getWireContent().algorithm,s.senderKey&&s.algorithm?(s.encrypted=!0,s.authenticated=!0,s.mismatchedSender=!0,s):(s.encrypted=!1,s)}checkUserTrust(e){return new f.UserVerificationStatus(!1,!1,!1)}getStoredCrossSigningForUser(e){return null}async checkOwnCrossSigningTrust(){}getVersion(){const e=i.getVersions();return`Rust SDK ${e.matrix_sdk_crypto} (${e.git_sha}), Vodozemac ${e.vodozemac}`}async getOwnDeviceKeys(){const e=await this.olmMachine.getDevice(this.olmMachine.userId,this.olmMachine.deviceId);if(e.curve25519Key&&e.ed25519Key)return{ed25519:e.ed25519Key.toBase64(),curve25519:e.curve25519Key.toBase64()};throw new Error("Device keys not found")}prepareToEncrypt(e){const t=this.roomEncryptors[e.roomId];t&&t.prepareForEncryption(this.globalBlacklistUnverifiedDevices)}forceDiscardSession(e){var t;return null===(t=this.roomEncryptors[e])||void 0===t?void 0:t.forceDiscardSession()}async exportRoomKeys(){const e=await this.olmMachine.exportRoomKeys((()=>!0));return JSON.parse(e)}async importRoomKeys(e,t){return await this.backupManager.importRoomKeys(e,t)}async userHasCrossSigningKeys(e=this.userId,t=!1){const s=await this.olmMachine.trackedUsers();let i;for(const t of s)if(e===t.toString()){i=t;break}if(void 0!==i){if(e===this.userId){const e=this.olmMachine.queryKeysForUsers([i]);await this.outgoingRequestProcessor.makeOutgoingRequest(e)}const t=await this.olmMachine.getIdentity(i);return null==t||t.free(),void 0!==t}if(t){var n;const t=null===(n=(await this.downloadDeviceList(new Set([e]))).master_keys)||void 0===n?void 0:n[e];return!!t&&Boolean(Object.values(t.keys)[0])}return!1}async getUserDeviceInfo(e,t=!1){const s=new Map,i=await this.getOlmMachineOrThrow().trackedUsers(),n=new Set;i.forEach((e=>n.add(e.toString())));const r=new Set;for(const t of e)n.has(t)?s.set(t,await this.getUserDevices(t)):r.add(t);if(t&&r.size>=1){const e=await this.downloadDeviceList(r);Object.entries(e.device_keys).forEach((([e,t])=>s.set(e,function(e){return new Map(Object.entries(e).map((([e,t])=>[e,v(t)])))}(t))))}return s}async getUserDevices(e){const t=new i.UserId(e),s=await this.olmMachine.getUserDevices(t,1);try{const e=s.devices();try{return new Map(e.map((e=>[e.deviceId.toString(),w(e,t)])))}finally{e.forEach((e=>e.free()))}}finally{s.free()}}async downloadDeviceList(e){const t={device_keys:{}};return e.forEach((e=>t.device_keys[e]=[])),await this.http.authedRequest(c.n$.Post,"/_matrix/client/v3/keys/query",void 0,t,{prefix:""})}getTrustCrossSignedDevices(){return this._trustCrossSignedDevices}setTrustCrossSignedDevices(e){this._trustCrossSignedDevices=e}async setDeviceVerified(e,t,s=!0){const n=await this.olmMachine.getDevice(new i.UserId(e),new i.DeviceId(t));if(!n)throw new Error(`Unknown device ${e}|${t}`);try{await n.setLocalTrust(s?i.LocalTrust.Verified:i.LocalTrust.Unset)}finally{n.free()}}async crossSignDevice(e){const t=await this.olmMachine.getDevice(new i.UserId(this.userId),new i.DeviceId(e));if(!t)throw new Error(`Unknown device ${e}`);try{const e=await t.verify();await this.outgoingRequestProcessor.makeOutgoingRequest(e)}finally{t.free()}}async getDeviceVerificationStatus(e,t){const s=await this.olmMachine.getDevice(new i.UserId(e),new i.DeviceId(t));if(!s)return null;try{return new f.DeviceVerificationStatus({signedByOwner:s.isCrossSignedByOwner(),crossSigningVerified:s.isCrossSigningTrusted(),localVerified:s.isLocallyTrusted(),trustCrossSignedDevices:this._trustCrossSignedDevices})}finally{s.free()}}async getUserVerificationStatus(e){const t=await this.getOlmMachineOrThrow().getIdentity(new i.UserId(e));if(void 0===t)return new f.UserVerificationStatus(!1,!1,!1);const s=t.isVerified();return t.free(),new f.UserVerificationStatus(s,!1,!1)}async isCrossSigningReady(){const{publicKeysOnDevice:e,privateKeysInSecretStorage:t,privateKeysCachedLocally:s}=await this.getCrossSigningStatus(),i=Boolean(s.masterKey)&&Boolean(s.selfSigningKey)&&Boolean(s.userSigningKey);return e&&(i||t)}async getCrossSigningKeyId(e=f.CrossSigningKey.Master){const t=await this.olmMachine.getIdentity(new i.UserId(this.userId));if(!t)return null;try{const s=await this.olmMachine.crossSigningStatus();if(!(s.hasMaster&&s.hasUserSigning&&s.hasSelfSigning))return null;if(!t.isVerified())return null;let i;switch(e){case f.CrossSigningKey.Master:i=t.masterKey;break;case f.CrossSigningKey.SelfSigning:i=t.selfSigningKey;break;case f.CrossSigningKey.UserSigning:i=t.userSigningKey;break;default:return null}const n=JSON.parse(i);return Object.values(n.keys)[0]}finally{t.free()}}async bootstrapCrossSigning(e){await this.crossSigningIdentity.bootstrapCrossSigning(e)}async isSecretStorageReady(){const e=["m.cross_signing.master","m.cross_signing.user_signing","m.cross_signing.self_signing"];return null!=await this.backupManager.getActiveBackupVersion()&&e.push("m.megolm_backup.v1"),K(this.secretStorage,e)}async bootstrapSecretStorage({createSecretStorageKey:e,setupNewSecretStorage:t,setupNewKeyBackup:s}={}){const i=t||!await this.secretStorageHasAESKey();if(i){if(!e)throw new Error("unable to create a new secret storage key, createSecretStorageKey is not set");this.logger.info("bootstrapSecretStorage: creating new secret storage key");const t=await e();await this.addSecretStorageKeyToSecretStorage(t)}const n=await this.olmMachine.crossSigningStatus();if(n.hasMaster&&n.hasSelfSigning&&n.hasUserSigning&&(i||!await R(this.secretStorage))){this.logger.info("bootstrapSecretStorage: cross-signing keys not yet exported; doing so now.");const e=await this.olmMachine.exportCrossSigningKeys();if(!e.masterKey)throw new Error("missing master key in cross signing private keys");if(!e.userSigningKey)throw new Error("missing user signing key in cross signing private keys");if(!e.self_signing_key)throw new Error("missing self signing key in cross signing private keys");await this.secretStorage.store("m.cross_signing.master",e.masterKey),await this.secretStorage.store("m.cross_signing.user_signing",e.userSigningKey),await this.secretStorage.store("m.cross_signing.self_signing",e.self_signing_key),s&&await this.resetKeyBackup()}}async addSecretStorageKeyToSecretStorage(e){var t,s;if(!e.keyInfo)throw new Error("missing keyInfo field in the secret storage key");const i=await this.secretStorage.addKey(S.SECRET_STORAGE_ALGORITHM_V1_AES,e.keyInfo);await this.secretStorage.setDefaultKeyId(i.keyId),null===(t=(s=this.cryptoCallbacks).cacheSecretStorageKey)||void 0===t||t.call(s,i.keyId,i.keyInfo,e.privateKey)}async secretStorageHasAESKey(){const e=await this.secretStorage.getKey();if(!e)return!1;const[,t]=e;return t.algorithm===S.SECRET_STORAGE_ALGORITHM_V1_AES}async getCrossSigningStatus(){const e=await this.getOlmMachineOrThrow().getIdentity(new i.UserId(this.userId)),t=Boolean(null==e?void 0:e.masterKey)&&Boolean(null==e?void 0:e.selfSigningKey)&&Boolean(null==e?void 0:e.userSigningKey);null==e||e.free();const s=await R(this.secretStorage),n=await this.getOlmMachineOrThrow().crossSigningStatus();return{publicKeysOnDevice:t,privateKeysInSecretStorage:s,privateKeysCachedLocally:{masterKey:Boolean(null==n?void 0:n.hasMaster),userSigningKey:Boolean(null==n?void 0:n.hasUserSigning),selfSigningKey:Boolean(null==n?void 0:n.hasSelfSigning)}}}async createRecoveryKeyFromPassphrase(e){let t;const s={};if(e){const i=await(0,C.Ar)(e);s.passphrase={algorithm:"m.pbkdf2",iterations:i.iterations,salt:i.salt},t=i.key}else t=new Uint8Array(32),_.eL.getRandomValues(t);return{keyInfo:s,encodedPrivateKey:(0,I.E)(t),privateKey:t}}async getEncryptionInfoForEvent(e){return this.eventDecryptor.getEncryptionInfoForEvent(e)}getVerificationRequestsToDeviceInProgress(e){return this.olmMachine.getVerificationRequests(new i.UserId(e)).filter((e=>void 0===e.roomId)).map((e=>new D(this.olmMachine,e,this.outgoingRequestProcessor,this._supportedVerificationMethods)))}findVerificationRequestDMInProgress(e,t){if(!t)throw new Error("missing userId");const s=this.olmMachine.getVerificationRequests(new i.UserId(t)).find((t=>{var s;return(null===(s=t.roomId)||void 0===s?void 0:s.toString())===e}));if(s)return new D(this.olmMachine,s,this.outgoingRequestProcessor,this._supportedVerificationMethods)}async requestVerificationDM(e,t){const s=await this.olmMachine.getIdentity(new i.UserId(e));if(!s)throw new Error(`unknown userId ${e}`);try{const e=this._supportedVerificationMethods.map((e=>x(e))),n=await s.verificationRequestContent(e),r=await this.sendVerificationRequestContent(t,n),o=await s.requestVerification(new i.RoomId(t),new i.EventId(r),e);return new D(this.olmMachine,o,this.outgoingRequestProcessor,this._supportedVerificationMethods)}finally{s.free()}}async sendVerificationRequestContent(e,t){const s=(0,j.O1)(32),{event_id:i}=await this.http.authedRequest(c.n$.Put,`/_matrix/client/v3/rooms/${encodeURIComponent(e)}/send/m.room.message/${encodeURIComponent(s)}`,void 0,t,{prefix:""});return i}setSupportedVerificationMethods(e){this._supportedVerificationMethods=null!=e?e:se}async requestOwnUserVerification(){const e=await this.olmMachine.getIdentity(new i.UserId(this.userId));if(void 0===e)throw new Error("cannot request verification for this device when there is no existing cross-signing key");try{const[t,s]=await e.requestVerification(this._supportedVerificationMethods.map(x));return await this.outgoingRequestProcessor.makeOutgoingRequest(s),new D(this.olmMachine,t,this.outgoingRequestProcessor,this._supportedVerificationMethods)}finally{e.free()}}async requestDeviceVerification(e,t){const s=await this.olmMachine.getDevice(new i.UserId(e),new i.DeviceId(t));if(!s)throw new Error("Not a known device");try{const[e,t]=await s.requestVerification(this._supportedVerificationMethods.map(x));return await this.outgoingRequestProcessor.makeOutgoingRequest(t),new D(this.olmMachine,e,this.outgoingRequestProcessor,this._supportedVerificationMethods)}finally{s.free()}}async getSessionBackupPrivateKey(){const e=await this.olmMachine.getBackupKeys();return e.decryptionKey?X.from(e.decryptionKey.toBase64(),"base64"):null}async storeSessionBackupPrivateKey(e,t){const s=(0,F.oF)(e);if(!t)throw new Error("storeSessionBackupPrivateKey: version is required");await this.backupManager.saveBackupDecryptionKey(i.BackupDecryptionKey.fromBase64(s),t)}async getActiveSessionBackupVersion(){return await this.backupManager.getActiveBackupVersion()}async isKeyBackupTrusted(e){return await this.backupManager.isKeyBackupTrusted(e)}async checkKeyBackupAndEnable(){return await this.backupManager.checkKeyBackupAndEnable(!0)}async deleteKeyBackupVersion(e){await this.backupManager.deleteKeyBackupVersion(e)}async resetKeyBackup(){const e=await this.backupManager.setupKeyBackup((e=>this.signObject(e)));await this.secretStorageHasAESKey()&&await this.secretStorage.store("m.megolm_backup.v1",e.decryptionKey.toBase64()),this.checkKeyBackupAndEnable()}async signObject(e){const t=new Map(Object.entries(e.signatures||{})),s=e.unsigned;delete e.signatures,delete e.unsigned;const i=t.get(this.userId)||{},n=o().stringify(e),r=await this.olmMachine.sign(n),a=JSON.parse(r.asJSON());t.set(this.userId,te(te({},i),a[this.userId])),void 0!==s&&(e.unsigned=s),e.signatures=Object.fromEntries(t.entries())}async getBackupDecryptor(e,t){if("m.megolm_backup.v1.curve25519-aes-sha2"!=e.algorithm)throw new Error(`getBackupDecryptor Unsupported algorithm ${e.algorithm}`);const s=e.auth_data;if(!(t instanceof Uint8Array))throw new Error("getBackupDecryptor expects Uint8Array");const n=i.BackupDecryptionKey.fromBase64((0,F.oF)(t));if(s.public_key!=n.megolmV1PublicKey.publicKeyBase64)throw new Error("getBackupDecryptor key mismatch error");return this.backupManager.createBackupDecryptor(n)}async importBackedUpRoomKeys(e,t){return await this.backupManager.importBackedUpRoomKeys(e,t)}async receiveSyncChanges({events:e,oneTimeKeysCounts:t=new Map,unusedFallbackKeys:s,devices:n=new i.DeviceLists}){const r=await this.olmMachine.receiveSyncChanges(e?JSON.stringify(e):"[]",n,t,s);return JSON.parse(r)}async preprocessToDeviceMessages(e){const t=await this.receiveSyncChanges({events:e});for(const e of t)e.type===u.tw.KeyVerificationRequest&&this.onIncomingKeyVerificationRequest(e.sender,e.content);return t}async processKeyCounts(e,t){const s=e&&new Map(Object.entries(e)),i=t&&new Set(t);void 0===s&&void 0===i||await this.receiveSyncChanges({oneTimeKeysCounts:s,unusedFallbackKeys:i})}async processDeviceLists(e){var t,s;const n=new i.DeviceLists(null===(t=e.changed)||void 0===t?void 0:t.map((e=>new i.UserId(e))),null===(s=e.left)||void 0===s?void 0:s.map((e=>new i.UserId(e))));await this.receiveSyncChanges({devices:n})}async onCryptoEvent(e,t){const s=t.getContent(),i=this.roomEncryptors[e.roomId];i?i.onCryptoEvent(s):this.roomEncryptors[e.roomId]=new d(this.olmMachine,this.keyClaimManager,this.outgoingRequestsManager,e,s)}onSyncCompleted(e){this.outgoingRequestsManager.doProcessOutgoingRequests().catch((e=>{this.logger.warn("onSyncCompleted: Error processing outgoing requests",e)}))}onIncomingKeyVerificationRequest(e,t){const s=t.transaction_id;if(!s||!e)return;const n=this.olmMachine.getVerificationRequest(new i.UserId(e),s);n&&this.emit(T.qG.VerificationRequestReceived,new D(this.olmMachine,n,this.outgoingRequestProcessor,this._supportedVerificationMethods))}onRoomMembership(e,t,s){const i=this.roomEncryptors[e.getRoomId()];i&&i.onRoomMembership(t)}async onRoomKeysUpdated(e){for(const t of e)this.onRoomKeyUpdated(t);this.backupManager.maybeUploadKey()}onRoomKeyUpdated(e){if(this.stopped)return;this.logger.debug(`Got update for session ${e.senderKey.toBase64()}|${e.sessionId} in ${e.roomId.toString()}`);const t=this.eventDecryptor.getEventsPendingRoomKey(e);if(0!==t.length){this.logger.debug("Retrying decryption on events:",t.map((e=>`${e.getId()}`)));for(const e of t)e.attemptDecryption(this,{isRetry:!0}).catch((t=>{this.logger.info(`Still unable to decrypt event ${e.getId()} after receiving key`)}))}}async onUserIdentityUpdated(e){const t=await this.getUserVerificationStatus(e.toString());this.emit(T.qG.UserTrustStatusChanged,e.toString(),t),e.toString()===this.userId&&await this.checkKeyBackupAndEnable()}async handleSecretReceived(e,t){return this.logger.debug(`onReceiveSecret: Received secret ${e}`),"m.megolm_backup.v1"===e&&await this.backupManager.handleBackupSecretReceived(t)}async checkSecrets(e){const t=await this.olmMachine.getSecretsFromInbox(e);for(const s of t)if(await this.handleSecretReceived(e,s))break;await this.olmMachine.deleteSecretsFromInbox(e)}async onLiveEventFromSync(e){if(e.isState()||e.getUnsigned().transaction_id)return;const t=async t=>{(function(e){switch(e.getType()){case u.tw.KeyVerificationCancel:case u.tw.KeyVerificationDone:case u.tw.KeyVerificationMac:case u.tw.KeyVerificationStart:case u.tw.KeyVerificationKey:case u.tw.KeyVerificationReady:case u.tw.KeyVerificationAccept:return!0;case u.tw.RoomMessage:return e.getContent().msgtype===u.Zw.KeyVerificationRequest;default:return!1}})(e)&&await this.onKeyVerificationRequest(t)};if(e.isDecryptionFailure()||e.isEncrypted()){const s=setTimeout((()=>e.off(a.xS.Decrypted,i)),3e5),i=(n,r)=>{r||(clearTimeout(s),e.off(a.xS.Decrypted,i),t(n))};e.on(a.xS.Decrypted,i)}else await t(e)}async onKeyVerificationRequest(e){const t=e.getRoomId();if(!t)throw new Error("missing roomId in the event");if(this.logger.debug(`Incoming verification event ${e.getId()} type ${e.getType()} from ${e.getSender()}`),await this.olmMachine.receiveVerificationEvent(JSON.stringify({event_id:e.getId(),type:e.getType(),sender:e.getSender(),state_key:e.getStateKey(),content:e.getContent(),origin_server_ts:e.getTs()}),new i.RoomId(t)),e.getType()===u.tw.RoomMessage&&e.getContent().msgtype===u.Zw.KeyVerificationRequest){const t=this.olmMachine.getVerificationRequest(new i.UserId(e.getSender()),e.getId());t?this.emit(T.qG.VerificationRequestReceived,new D(this.olmMachine,t,this.outgoingRequestProcessor,this._supportedVerificationMethods)):this.logger.info(`Ignoring just-received verification request ${e.getId()} which did not start a rust-side verification`)}this.outgoingRequestsManager.doProcessOutgoingRequests().catch((e=>{this.logger.warn("onKeyVerificationRequest: Error processing outgoing requests",e)}))}}class ne{constructor(e,t,s){this.logger=e,this.olmMachine=t,this.perSessionBackupDownloader=s,(0,n.Z)(this,"eventsPendingKey",new m.kc((()=>new m.kc((()=>new Set)))))}async attemptEventDecryption(e){this.addEventToPendingList(e);try{const t=await this.olmMachine.decryptRoomEvent(re(e),new i.RoomId(e.getRoomId()));return this.removeEventFromPendingList(e),{clearEvent:JSON.parse(t.event),claimedEd25519Key:t.senderClaimedEd25519Key,senderCurve25519Key:t.senderCurve25519Key,forwardingCurve25519KeyChain:t.forwardingCurve25519KeyChain}}catch(t){if(t instanceof i.MegolmDecryptionError){const s=e.getWireContent();let n;switch(t.code){case i.DecryptionErrorCode.MissingRoomKey:n=new Z.NX("MEGOLM_UNKNOWN_INBOUND_SESSION_ID","The sender's device has not sent us the keys for this message.",{session:s.sender_key+"|"+s.session_id}),this.perSessionBackupDownloader.onDecryptionKeyMissingError(e.getRoomId(),e.getWireContent().session_id);break;case i.DecryptionErrorCode.UnknownMessageIndex:n=new Z.NX("OLM_UNKNOWN_MESSAGE_INDEX","The sender's device has not sent us the keys for this message at this index.",{session:s.sender_key+"|"+s.session_id}),this.perSessionBackupDownloader.onDecryptionKeyMissingError(e.getRoomId(),e.getWireContent().session_id);break;default:n=new Z.NX("UNABLE_TO_DECRYPT",t.description,{session:s.sender_key+"|"+s.session_id})}throw n}throw new Z.NX("UNABLE_TO_DECRYPT","Unknown error")}}async getEncryptionInfoForEvent(e){if(!e.getClearContent()||e.isDecryptionFailure())return null;if(null!==e.status)return{shieldColour:f.EventShieldColour.NONE,shieldReason:null};const t=await this.olmMachine.getRoomEventEncryptionInfo(re(e),new i.RoomId(e.getRoomId()));return function(e,t){if(void 0===t)return null;const s=t.shieldState(!1);let n,r;switch(s.color){case i.ShieldColor.Grey:n=f.EventShieldColour.GREY;break;case i.ShieldColor.None:n=f.EventShieldColour.NONE;break;default:n=f.EventShieldColour.RED}void 0===s.message?r=null:"Encrypted by an unverified user."===s.message?r=f.EventShieldReason.UNVERIFIED_IDENTITY:"Encrypted by a device not verified by its owner."===s.message?r=f.EventShieldReason.UNSIGNED_DEVICE:"The authenticity of this encrypted message can't be guaranteed on this device."===s.message?r=f.EventShieldReason.AUTHENTICITY_NOT_GUARANTEED:"Encrypted by an unknown or deleted device."===s.message?r=f.EventShieldReason.UNKNOWN_DEVICE:(e.warn(`Unknown shield state message '${s.message}'`),r=f.EventShieldReason.UNKNOWN);return{shieldColour:n,shieldReason:r}}(this.logger,t)}getEventsPendingRoomKey(e){const t=this.eventsPendingKey.get(e.senderKey.toBase64());if(!t)return[];const s=t.get(e.sessionId);if(!s)return[];const i=e.roomId.toString();return[...s].filter((e=>e.getRoomId()===i))}addEventToPendingList(e){const t=e.getWireContent(),s=t.sender_key,i=t.session_id;this.eventsPendingKey.getOrCreate(s).getOrCreate(i).add(e)}removeEventFromPendingList(e){const t=e.getWireContent(),s=t.sender_key,i=t.session_id,n=this.eventsPendingKey.get(s);if(!n)return;const r=n.get(i);r&&(r.delete(e),0===r.size&&(n.delete(i),0===n.size&&this.eventsPendingKey.delete(s)))}}function re(e){return JSON.stringify({event_id:e.getId(),type:e.getWireType(),sender:e.getSender(),state_key:e.getStateKey(),content:e.getWireContent(),origin_server_ts:e.getTs()})}async function oe(e,t,s,n,r,o,a,c){var u;await i.initAsync(),new i.Tracing(i.LoggerLevel.Debug).turnOn();const g=new i.UserId(s),h=new i.DeviceId(n);e.info("Init OlmMachine");const d=await i.OlmMachine.initialize(g,h,null!=a?a:void 0,null!==(u=a&&c)&&void 0!==u?u:void 0);d.roomKeyRequestsEnabled=!1;const l=new ie(e,d,t,s,n,r,o);return await d.registerRoomKeyUpdatedCallback((e=>l.onRoomKeysUpdated(e))),await d.registerUserIdentityUpdatedCallback((e=>l.onUserIdentityUpdated(e))),l.checkSecrets("m.megolm_backup.v1"),await d.registerReceiveSecretCallback(((e,t)=>l.checkSecrets(e))),await d.outgoingRequests(),e.info("Completed rust crypto-sdk setup"),l}}}]);
//# sourceMappingURL=2606.js.map